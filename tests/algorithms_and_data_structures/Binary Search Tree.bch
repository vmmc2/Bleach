/*
Code that implements the Binary Search Tree data-structure by using a pointers approach.
*/

class TreeNode{
  method init(key, value){
    self.key = key;
    self.value = value;
    self.left = nil;
    self.right = nil;
  }

  method str(){
    return "Node Key: " + self.key + " - Node Value: " + self.value;
  }
}

class BST{
  method init(){
    self.root = nil;
    self.length = 0;
  }

  method insert(key, value){
    if(self.root == nil){
      self.root = TreeNode(key, value);
    }else{
      let curr = self.root;
      while(true){
        if(key < curr.key and curr.left == nil){
          curr.left = TreeNode(key, value);
          break;
        }elif(key < curr.key and curr.left != nil){
          curr = curr.left;
        }elif(curr.key < key and curr.right == nil){
          curr.right = TreeNode(key, value);
          break;
        }else{
          curr = curr.right;
        }
      }
    }

    self.length = self.length + 1;

    return;
  }

  method delete(key){
    // TODO: Finish implementation of this.
    let deletedNode;


    self.length = self.length - 1;

    return deletedNode;
  }

  method find(key){
    let curr = self.root;

    while(curr != nil and curr.key != key){
      if(key < curr.key){
        curr = curr.left;
      }else{
        curr = curr.right;
      }
    }

    return curr == nil ? "Could not find the key inside the BST" : curr;
  }

  method size(){
    return self.length;
  }

  method findMaximum(){
    let curr = self.root;
    if(curr == nil){
      return "The BST is empty.";
    }
    while(curr.right != nil){
      curr = curr.right;
    }

    return curr.value;
  }

  method findMinimum(){
    let curr = self.root;
    if(curr == nil){
      return "The BST is empty";
    }
    while(curr.left != nil){
      curr = curr.left;
    }

    return curr.value;
  }

  method preorderTraversal(curr){
    if(curr == nil){
      return;
    }
    std::io::print(curr);
    self.preorderTraversal(curr.left);
    self.preorderTraversal(curr.right);
  
    return;
  }

  method inorderTraversal(curr){
    if(curr == nil){
      return;
    }
    self.preorderTraversal(curr.left);
    std::io::print(curr);
    self.preorderTraversal(curr.right);
  
    return;
  }

  method postorderTraversal(curr){
    if(curr == nil){
      return;
    }
    self.preorderTraversal(curr.left);
    self.preorderTraversal(curr.right);
    std::io::print(curr);

    return;
  }

  method str(){
    return "BST representation.";
  }
}

function main(){
  let bst = BST();
  
  bst.insert(10, 10);
  bst.insert(2, 2);
  bst.insert(23, 23);

  bst.inorderTraversal(bst.root);

  return;
}

main();