/*
Code that implements the Binary Search Tree data-structure by using a pointers approach.
*/

class TreeNode{
  method init(key, value){
    self.key = key;
    self.value = value;
    self.left = nil;
    self.right = nil;
  }

  method str(){
    return "Node Key: " + self.key + " - Node Value: " + self.value;
  }
}

class BST{
  method init(){
    self.root = nil;
    self.length = 0;
  }

  method insert(key, value){
    if(self.root == nil){
      self.root = TreeNode(key, value);
    }else{
      let curr = self.root;
      while(true){
        if(key < curr.key and curr.left == nil){
          curr.left = TreeNode(key, value);
          break;
        }elif(key < curr.key and curr.left != nil){
          curr = curr.left;
        }elif(curr.key < key and curr.right == nil){
          curr.right = TreeNode(key, value);
          break;
        }else{
          curr = curr.right;
        }
      }
    }

    self.length = self.length + 1;

    return;
  }

  method aux_delete(root, key){
    if(root == nil){
      return root;
    }

    if(key < root.key){
      root.left = self.aux_delete(root.left, key);
    }elif(key > root.key){
      root.right = self.aux_delete(root.right, key);
    }else{
      // Scenario where the node to be deleted has one child or no child.
      if(){

      }elif(){

      }
    }

    return root;
  }

  method delete(key){
    self.root = self.aux_delete(self.root, key);

    self.length = self.length - 1;

    return;
  }

  method find(key){
    let curr = self.root;

    while(curr != nil and curr.key != key){
      if(key < curr.key){
        curr = curr.left;
      }else{
        curr = curr.right;
      }
    }

    return curr == nil ? "Could not find the key inside the BST" : curr;
  }

  method size(){
    return self.length;
  }

  method findMinimum(node){
    let curr = node;

    while(curr.left != nil){
      curr = curr.left;
    }

    return curr;
  }

  method preorderTraversal(curr){
    if(curr == nil){
      return;
    }
    std::io::print(curr);
    self.preorderTraversal(curr.left);
    self.preorderTraversal(curr.right);
  
    return;
  }

  method inorderTraversal(curr){
    if(curr == nil){
      return;
    }
    self.inorderTraversal(curr.left);
    std::io::print(curr);
    self.inorderTraversal(curr.right);
  
    return;
  }

  method postorderTraversal(curr){
    if(curr == nil){
      return;
    }
    self.postorderTraversal(curr.left);
    self.postorderTraversal(curr.right);
    std::io::print(curr);

    return;
  }

  method str(){
    return "BST representation.";
  }
}

function main(){
  let bst = BST();
  
  bst.insert(10, 10);
  bst.insert(2, 2);
  bst.insert(23, 23);
  bst.insert(5, 5);
  bst.insert(14, 14);

  bst.inorderTraversal(bst.root);

  return;
}

main();